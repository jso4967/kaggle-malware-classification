===============================
prepare_bytes_ngrams_2_model.py
===============================
<----------------* 정리 *----------------------------------------------------------->
데이터 처리가 되었는지 확인한 후 feature에 대한 값이 json으로 구성되어 있는 데이터 파일을 처리하여 
특징 중 최다빈도순으로 정렬된 csv 파일을 만든다.
csv 파일이 작성 되었다면 csv 파일을 pd 파일로 변환한다.
<---------------------------------------------------------------------------------->
해당 파이썬 프로그램의 인자값의 calc_stats 값이 True인 경우 // 인자가 train 혹은 sample인 경우
calc_top_n_ngrams()
    1. json으로 작성된 파일을 연다.
    2. 해당 파일에서 한 문장씩 읽어들인다.
        2.1. 읽은 값을 json 오브젝트로 저장한다.
        2.2. 저장 된 json 오브젝트에서 key와 value 값을 하나씩 읽어들인다.
            2.2.1 json 오브젝트의 키 값이 'key'인가?
                2.2.1.1 Yes : 계속 진행한다.
                2.2.2.2 No : 키 값이 튜플임으로 key_to_str() 함수를 사용하여 튜플을 문자열로 변환시켜 저장한다.
            2.2.2.  Counter 객체를 이용하여 json에서 각 키에 대한 value 값의 수를 센다.
    3. counter 객체에 저장된 각 키에 대한 value의 개수 데이터를 튜플 형식으로 변환한다.
    4. counter 객체를 value값에 대해 역순으로 정렬한다. 즉 큰 값이 앞에 오게 정렬한다.
    5. counter 내부 정렬된 값들 중에서 상위 n개만 모아서 dictionary 형태로 counter에 다시 저장한다.
    6. max_bytes_ngrams_top_n.txt 라는 파일에 이를 다시 json 형식으로 바꿔 저장한다.

해당 파이썬 프로그램의 인자값이 calc_stats 값이 Flase인 경우 그리고 env가 test인 경우
build_model()
    1. env에 맞는 파일을 하나 열어서 첫번째 줄을 읽어들인다. 
    2. 읽어들인 값에서 key 값을 max_keys 변수에 따로 저장한다.
    3. key 값을 정렬한다. // 가장 빈도수가 높은 key 값 순으로
    4. 파일에서 한 줄씩 읽어들인다.
        4.1. json 객체에서 key와 value 값을 각각 읽어 와서 dictionary 자료형으로 변환하여 저장한다.
        4.2. max_keys 변수에 있는 key 값을 하나씩 불러와서 위 변수에서 해당 key값의 value 값을 가져온다. default는 0
        4.3. 가져온 값과 해당 값에 대한 'key'값을 current에 저장하고 current를 features 변수에 저장한다.
    5. features 변수에 있는 값으로 pd.dataframe을 작성한다. 그리고 만들어진 표를 다시 features에 저장한다.
    6. 해당 표를 csv 혹은 pd 파일로 저장한다.

========================
extract_asm_features.py
========================
<-----------------------------------------*정리*-------------------------------------->
multiprocess 패키지를 이용하여 실시간 처리를 진행한다.
큐에 들어가는 파일에서 코드 섹션, 어셈블리관련특징, opcode의 ngram 등을 찾아서 특징 집합을 만든다.
코드 섹션을 찾을 때는 :text 문자열을 이용하여 찾았고, 어셈블리 특징은 어셈블리어에서 바이러스에서 자주
사용되는 단어들을 하드코딩한 후, 이 값이 해당 파일에 존재하는지 몇개 존재하는지를 파악하는 방식이다. 
opcode는 주석을 모두 제외하고, 또한 바이러스에서 자주 사용되는 헥스값들을 파일 내부에서 센다.
이 특징값들을 모두 모아 반환한다.
<------------------------------------------------------------------------------------>
1. 프로그램의 인자값을 이용해서 폴더를 설정한다.
2. 프로그램의 인자값을 이용해서 limit 값을 설정한다.
3. 프로그램 인자값을 이용해서, 입력 파일, 출력 파일의 형식을 구하고, process_asm과 관련된 람다 함수, 
    아까 구한 limit를 이용해서 crunch 함수를 실행시킨다.
    3.1. crunching 하는 파일이 무엇인지 limit는 무엇인지 출력한다.
    3.2. JoinableQueue 객체를 default값 40으로 생성한다.
    3.3. Queue 객체를 생성한다.
    3.4. Pool 객체를 생성한다.
        3.4.1. JoinableQueue에 있는 항목을 제거하고 반환하여, (key, text) 자료를 반환한다.
        3.4.2. text를 합치고, '\r\n' 문자를 기준으로 나눈다.
        3.4.3. process_asm 메소드 실행
            3.4.3.1. 모든 라인을 소문자로 바꾼다.
            3.4.3.2. 파일의 라인들 전체에서 라인 처음부터 ':'문자 바로 뒤 문자까지의 문자열을 
                    특징으로 잡고 해당 특징이 얼마나 나오는지를 dictionary로 저장하여 반환한다.
            3.4.3.3. 코드 섹션을 찾는다.
                3.4.3.3.1. .text로 시작하면 code에 저장, 시작하지 않으면, 탭을 띄어쓰기로 바꾸었을 때 
                            'segement type: pure code'가 있다면 파일의 라인들 전체에서 라인 처음부터 
                            ':'문자 바로 뒤 문자까지의 문자열을 특징으로 잡고 해당 특징이 얼마나 나오는지를 
                            dictionary로 변환하여 section에 저장한다.
                    3.4.3.3.1.1. 만약 section이 있다면, found new code section ~~을 출력
                    3.4.3.3.1.2. code_section에 추가
            3.4.3.4. 찾은 코드 섹션 부분 라인들을 code에 저장한다.
            3.4.3.5. asm_misc_feature과 관련된 key 값이 파일 전체에 얼마나 있는지 전부 세어 asm_misc에 저장.
                3.4.3.5.1. 있다면 : 해당 키값이 몇개 있는재 counter 객체로 세고 dictionary로 반환.
            3.4.3.6. code가 없다면 코드 섹션이 없다고 출력
            3.4.3.7. 파일 전체에서 opcode를 찾는다.
                3.4.3.7.1. 각 라인에서  띄어쓰기를 찾는다.
                    3.4.3.7.1.1. 있다면 current_block에 값이 존재한다면 currentblock을 opcodes에 추가
                    3.4.3.7.1.2. 없다면 
                        3.4.3.7.1.2.1. 해당 라인에서 띄어쓰기 바로 앞 문자부터 맨 뒤의 문자를 strip으로 분리하여 line에 저장한다..
                        3.4.3.7.1.2.2. 만약 첫 문자가 세미콜론이면 parse_asm_command를 실행한다.
                            3.4.3.7.1.2.2.1. 해당 라인에서 ; 가 발견되면 처음 부터 ;가 발견된 지점 까지의 라인을 반환한다. 없으면 그냥 반환한다.
                            3.4.3.7.1.2.2.2. 라인에 있는 값들을 탭으로 분리해서 skip_hex_groups를 실행
                                3.4.3.7.1.2.2.1. 값이 g_hex_group이면 해당 값들의 모음을 반환
                            3.4.3.7.1.2.2.3. hex_group이 존재하지 않으면 None을 반환
                            3.4.3.7.1.2.2.4. hex_group이 존재하면 line에서 + 를 띄어쓰기 문자로 교체하고 띄어쓰기를 기준으로 나눈다.
                            3.4.3.7.1.2.2.5. 특정 값과 위에서 나눈 값이 일치 하는 부분이 있으면 그 부분을 cmd에 저장한다.
                            3.4.3.7.1.2.2.6. cmd의 값이 없고, items가 존재하면
                                3.4.3.7.1.2.2.6.1. items는 g_hex_value 값이 없을 때 부터 그 이후의 값을 반환한다.
            3.4.3.8. 찾은 opcode로 ngram을 만든다.
                3.4.3.8.1. ngram에서 나온 주요 특징들을 추출하여 배열형태로 반환
            3.4.4.9. feature_sets가 반환됨
            3.4.4.10. np.savez_compressed로 features를 key로 압축하여 저장한다음 1을 반환한다.
        3.4.4. 결과 값을 큐에 넣고, q_in을 task_done 메소드로 끝낸다.
    3.5. 7zip 파일에서 파일을 각각 불러온다.
        3.5.1. 불러온 파일의 확장자가 ext_type과 같다면 해당 파일을 key와 text로 나누어 큐에 넣는다.
        3.5.2. 해당 파일이 진행 중임을 출력한다.
        3.5.3. 모든 일이 일이 끝나면 큐를 닫고, 풀도 닫는다.
    3.6. 큐에서 각각의 값을 result 변수에 담고 이를 반환한다.

